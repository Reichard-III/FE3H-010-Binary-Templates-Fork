//------------------------------------------------
//--- 010 Editor v15.0.2 Binary Template
//
//      File: fixed_freescenario.bin
//   Authors: Reichard
//   Version: 1.0
//   Purpose: 
//  Category: Reichard
// File Mask: *fixed_freescenariodata.bin
//  ID Bytes: 
//   History: 
//   1.1    09/02/25 ReichardTheThird: 99% of Data Found, only AuxItemReward.UnkShort0x0 is unknown
//   1.0    08/16/25 ReichardTheThird: Started template
//------------------------------------------------
#include "Structs.bt"

LittleEndian();
local int i =0;

enum<ubyte> AuxIndex{
    Aux_BattleInTheOutskirts,
    Aux_BattleInTheMountains,
    Aux_BattleInTheEmpire,
    Aux_BattleInTheKingdom,
    Aux_BattleInTheDesert,
    Aux_BattleInTheMagred,
    Aux_BattleInTheAlmyra,
    Aux_BattleInThePlateau,
    Aux_MonstersOnTheRoad,
    Aux_MonstersInTheMountains,
    Aux_MonstersInTheDesert,
    Aux_BattleAtGronderField,
    Aux_MonstersAtGronderField,
    Aux_BattleInTheRuins,
    Aux_MonstersInTheRuins,
    Aux_MonstersInTheRedCanyon,
    Aux_BanditsOnTheRhodosCoast,
    Aux_WesternChurchSuppression,
    Aux_BattleInAillel,
    Aux_MonstersOnThePlains,
    GoldAux_BattleAtLakeTeutates,
    GoldAux_BattleInTheForest,
    GoldAux_BattleInThePlains,
    GoldAux_BattleAtTheSealedForest,
    GoldAux_BattleAtConandTower,
    Semilogue_Jeritza
};


//Entry layout
struct sAuxItemReward{
    ushort unkShort0x0<name="UnusedShort0x0?">;
    RewardBinType RewardBin;
    MiscItem RewardItem;
    ubyte RewardCount;
    ubyte RollThreshold[3]<comment="indexed by Aux battle selection index, if roll exceeds this amount, then decrement amount from roll and check next entry in bin#">;
};

struct sAuxSpawnLimit{
    AuxUnitBin RedEnemyBin;
    ubyte SpawnLimit<name="SpawnLimit">;
    local AuxIndex AuxI=i;
};

struct sAuxUnit{
    CharID Character;
    AuxUnitBin RedEnemyBin;
    ubyte MaximumChapter;
    ubyte MinimumChapter;
    ClassID Class;
    BattalionID Battalion;
    ubyte UnitCount;
    struct sUnitFlags{
        byte bit0:1<name="Allowed In Random Pool?",comment="If not enabled then this is a quest only entry ">;
        byte bit1:1<name="RarerEnemies?",comment="Seems to reserve up to a 1/4 of Spawnable enemies for rarer enemies">;
        byte bit2:1<name="Green Ally">;
        byte bit3:1;
       
        byte bit4:1;
        byte bit5:1;
        byte bit6:1;
        byte bit7:1;
    }UnitFlags;
    ubyte unkByte0x9<name="Padding?">;
};

struct sMonsterDroppableWeaponsEntry{
    Item_Adjusted MonsterDroppableWeapon;
    ubyte RollCosts[4];
};

struct sAuxYellowMonsterUnit{
    CharID Character;
    ClassID Class;
    ubyte EncounterChance;
};

struct sAuxMoneyReward{
    ushort BaseMoney;
    
    local int chapter=i;
};

//loop
struct sAuxItemRewards{
    DataSection Header;
    for(i=0; i<Header.NumEntries;i++){
        sAuxItemReward AuxItemReward<read= Str("%s - %d%% %d%% %d%% - %s - %d",EnumToString(RewardBin),RollThreshold[0], RollThreshold[1],RollThreshold[2] ,EnumToString(RewardItem),RewardCount)>;
    }
};

struct sAuxSpawnLimits{
    DataSection Header;
    for(i=0; i<Header.NumEntries;i++){
        sAuxSpawnLimit AuxSpawnLimit<read=EnumToString(AuxI)>;
    }
};

struct sAuxUnits{
    DataSection Header;
    for(i=0; i<Header.NumEntries;i++){
        sAuxUnit AuxUnit<read=Str("Chapter %2d-%2d: %s %s",MinimumChapter,MaximumChapter,EnumToString(RedEnemyBin),EnumToString(Class))>;
    }
};

struct sMonsterDroppableWeapons{
    DataSection Header;
    for(i=0; i<Header.NumEntries;i++){
        sMonsterDroppableWeaponsEntry Entries<read=Str("%2d %2d %2d %2d - %s",RollCosts[0],RollCosts[1],RollCosts[2],RollCosts[3],EnumToString(MonsterDroppableWeapon))>;
    }
};

struct sAuxYellowMonsterUnits{
    DataSection Header;
    for(i=0; i<Header.NumEntries;i++){
        sAuxYellowMonsterUnit AuxYellowMonsterUnit<read=Str("%d%% %s",EncounterChance,EnumToString(Class))>;
    }
};

struct sAuxMoneyRewardRewards{
    DataSection Header;
    for(i=0; i<Header.NumEntries;i++){
        sAuxMoneyReward AuxMoneyReward<read=Str("Chapter %d",chapter)>;
    }
};

struct freeScenario {
    FileSections Sections;
    sAuxItemRewards AuxItemRewards;
    sAuxSpawnLimits AuxSpawnLimits;
    sAuxUnits AuxUnits;
    sMonsterDroppableWeapons MonsterDroppableWeapons;
    sAuxYellowMonsterUnits AuxYellowMonsterUnits<comment="Unknown if you can put nonMonsters here">;
    sAuxMoneyRewardRewards AuxMoneyRewards<comment="This gets multiplied by reward multipliers">;
    byte padding[2];

}File<open=true>;