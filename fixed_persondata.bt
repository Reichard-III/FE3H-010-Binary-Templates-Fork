//------------------------------------------------
//--- 010 Editor v14.0 Binary Template
//
//      File: fixed_persondata.bt
//   Authors: DeathChaos, Moonling, Triabolical, ReichardTheThird
//   Version: 1.10
//   Purpose: Determines character learnsets, growths, magic, support pairs, etc.
//  Category: Reichard
// File Mask: *fixed_persondata.bin
//  ID Bytes: 
//   History: 
//   1.10    2/16/25 ReichardTheThird: Started taking over maintainance and updates from previous authors
//   1.09    2020-02-18  DeathCha0s - Fix AID blocks from 1.1.0, add base Battalion
//   1.08    2019-09-04  DeathChaos - Added Enemy Personal Skills
//   1.07    ----------  Moonling - Added Spell List and Skills
//   1.06    ----------  DeathChaos - Added Starting Weapon Ranks and Proficiencies
//   1.05    ----------  DeathChaos - Added Character Goals
//   1.04    ----------  DeathChaos - Added Portrait IDs
//   1.03    ----------  DeathChaos - Added Facculty Related stuff
//   1.02    ----------  DeathChaos - Added Voice ID
//   1.01    ----------  DeathChaos - Added AID
//   1.00    2019-08-05  DeathChaos - started this
//------------------------------------------------


//---------------------------------------------
// Includes
//---------------------------------------------
#include "Structs.bt"
LittleEndian();
FSeek(0);
local int i<hidden=true>;
struct File{
	struct SectionPointers{
		uint32 NumberOfSectionPointers;
		uint32 PointerToCharBlocks<bgcolor=cRed>;
		uint32 CharBlockStructSize<bgcolor=cRed>;
		uint32 PointerToAssetID<bgcolor=cBlue>;
		uint32 AssetIDStructSize<bgcolor=cBlue>;
		uint32 PointerToVoiceID<bgcolor=cPurple>;
		uint32 VoiceIDStructSize<bgcolor=cPurple>;
		uint32 PointerToWpnRanks<bgcolor=cDkYellow>;
		uint32 WpnRanksStructSize<bgcolor=cDkYellow>;
		uint32 PointerToSpellLearnset<bgcolor=cYellow>;
		uint32 SpellLearnsetStructSize<bgcolor=cYellow>;
		uint32 PointerToSkillLearnset<bgcolor=cYellow>;
		uint32 SkillLearnsetStructSize<bgcolor=cYellow>;
		uint32 PointerToStartingWeapons<bgcolor=cDkBlue>;
		uint32 StartingWeaponsStructSize<bgcolor=cDkBlue>;
		uint32 PointerToArtLearnset<bgcolor=cYellow>;
		uint32 ArtLearnsetStructSize<bgcolor=cYellow>;
		uint32 LinkedAttackPtr<bgcolor=cYellow>;
		uint32 LinkedAttackSize<bgcolor=cYellow>;
		uint32 LinkedAttackSpecialPtr<bgcolor=cYellow>;
		uint32 LinkedAttackSpecialSize<bgcolor=cYellow>;
		uint32 SupportListPointer<bgcolor=cYellow>;
		uint32 SupportListSize<bgcolor=cYellow>;
		uint32 PointerToHiddenTalent<bgcolor=cYellow>;
		uint32 HiddenTalentStructSize<bgcolor=cYellow>;
		uint32 UnkPointer04<bgcolor=cYellow>;
		uint32 UnkTotalSize04<bgcolor=cYellow>;
		uint32 PointerToFacultyTraining<bgcolor=cBlack>;
		uint32 FacultyTrainingStructSize<bgcolor=cBlack>;
		uint32 PointerToSeminar<bgcolor=cGreen>;
		uint32 SeminarTotalSize<bgcolor=cGreen>;
		uint32 Size3Pointer<bgcolor=cDkRed>;
		uint32 Size3TotalSize<bgcolor=cDkRed>;
		uint32 PortraitsPointer<bgcolor=cDkPurple>;
		uint32 PortraitsTotalSize<bgcolor=cDkPurple>;
		uint32 SizeFourPointer<bgcolor=cDkGreen>;
		uint32 SizeFourTotalSize<bgcolor=cDkGreen>;
	}sectionpointers<name="Section Pointers">;
	FSeek(sectionpointers.PointerToCharBlocks);
	struct PersonStructure{
        DataSection Header;
        Person person[Header.NumEntries]<read=ReadNameID, name="Character Block">;
	}personstructure<bgcolor=cRed, name="Character Blocks">;
    // file.personstructure.person[i].
	FSeek(sectionpointers.PointerToAssetID);
	struct AssetIDStructure{
		uint32 AID_Magic;
		uint32 numAID;
		uint32 SizeOfAIDBlock;
		struct AIDHeaderPadding{
			byte Padding[0x34];
		}aidheaderpadding<name="Padding">;
		struct AssetID{
			int16 NGPlusHair<name="NG+ Hair?">;
			int16 TimeSkipHeadModel<name="Part 2 Head Model">;
			int16 TimeSkipPortrait<name="Part 2 Portraits">;
			int16 PreTimeSkipHead<name="Part 1 Head Model">;
			int16 PreTimeSkipPortrait<name="Part 1 Portrait">;
			int16 BodyModelTimeSkip<name="Part 2 Model">;
			int16 DLCOutfit<name="Post Sothis Fusion Asset ID (Flag Set)">;
			int16 BodyModelPreTimeSkip<name="Part 1 Model">;
			int16 AlternateStatePortrait<name="Alternate State Portrait (Constance)">;
		}assetid[numAID]<bgcolor=cGreen>;
	}assetidstructure<bgcolor=cBlue, name="Asset IDs">;
	
	FSeek(sectionpointers.PointerToVoiceID);
	struct VoiceIDStructure{
		uint32 Voice_Magic;
		uint32 numVoice;
		uint32 SizeOfVoiceBlock;
		struct VoiceHeaderPadding{
			byte Padding[0x34];
		}voiceheaderpadding<name="Padding">;
		struct VoiceID{
			uint16 voice;
			uint16 voice;
			uint16 voice;
			uint16 voice;
		}voiceid[numVoice];
	}voicestructure<bgcolor=cPurple, name="Voice IDs">;
	
	FSeek(sectionpointers.PointerToWpnRanks);
	struct WpnRankStructure{
		uint32 WpnRank_Magic<bgcolor=cRed>;
		uint32 numWpnRank<bgcolor=cRed>;
		uint32 SizeOfWpnRankBlock<bgcolor=cRed>;
	    byte Padding[0x34]<bgcolor=cBlue>;
		struct WpnRank{
            for( i = 0; i < numWpnRank; i++ ){    
                struct WpnRankData {
                    local CharID name<hidden=true>;
                    name = GetPlayableIndex(i);
			        ubyte autolevels<name="Number of Timeskip Autolevels">;
                    bf8 unk;
			        PaletteID CharColor<name="Character Color">;
			        ClassID defaultClass<name="Default Class">;
			        ClassID certclass[4]<name="Pre-Certified Classes">;
                    struct combatFlags {
				        ubyte bit0 : 1<name="Default Class Mastered">;
				        ubyte bit1 : 1<name="Certified Class Mastered 0">;
				        ubyte bit2 : 1<name="Certified Class Mastered 1">;
				        ubyte bit3 : 1<name="Certified Class Mastered 2">;
				        ubyte bit4 : 1<name="Certified Class Mastered 3">;
				        ubyte bit5 : 1<name="Unknown">;
                        ubyte bit6 : 1<name="Unknown">;
                        ubyte bit7 : 1<name="Minimum 2 Stat Level Ups">;
                    }flags<name="Combat Related Flags">;
                    ubyte startingRanks[11];
                    ubyte weaponProf[11];
                    //StartingRanks StartWepRanks<name="Starting Weapon Ranks", bgcolor=cBlue>;
                    //WpnProficiency wpnproficiency<name="Proficiencies">;
			        ClassID class<name="Post TimeSkip Unique Class">;
			        ClassID class<name="Post TimeSkip Unique Class">;
			        ClassID class<name="Post TimeSkip Unique Class">;
                }wpnrankdata<name="Wpn Ranks/Assets Data", read=EnumToString(name)>;
            }
		}wpnrank<name="Starting Weapon Ranks and Combat Assets">;
	}wpnrankstructure<bgcolor=cDkYellow, name="Starting Weapon Ranks and Combat Assets">;
	
	FSeek(sectionpointers.PointerToStartingWeapons);
	struct StartingWeaponsStructure{
		uint32 Weapons_Magic;
		uint32 numStartWep;
		uint32 SizeOfStartWep;
		struct StartWeaponHeaderPadding{
			byte Padding[0x34];
		}startweaponheaderpadding<name="Padding">;
        for (i = 0; i < numStartWep; ++i){
		struct StartWepID{
            local CharID NameOfChar<hidden=true>;
            NameOfChar = GetPlayableIndex(i); 
			int16 Flag<name="Item Flag?">;
			Item Weapon1<name="Item Slot 1">;
			Item Weapon2<name="Item Slot 2">;
			Item Weapon3<name="Item Slot 3">;
			Item Weapon4<name="Item Slot 4">;
			Item Weapon5<name="Item Slot 5">;
			Item Weapon6<name="Item Slot 6">;
		}startwepid<name="Starting Inventory", read=EnumToString(NameOfChar)>;
    }
}startingweaponsstructure<bgcolor=cDkBlue, name="Starting Weapons">;
	
	FSeek(sectionpointers.PointerToFacultyTraining);
	struct FacultyTraining{
		uint32 FacultyMagic;
		uint32 numFaculty;
		uint32 SizeOfFaculty;
		struct FacultyHeaderPadding{
			byte Padding[0x34];
		}facultyheaderpadding<name="Padding">;
		struct FacultyID{
            StatBits statbits<name="Teachable Stats">;
			CharID CharacterID<name="Character ID">;
			TrueFalse IsTeacher<name="IsTeacher">;
			byte padding;
		}facultyid[numFaculty]<name="Faculty Training Stuff", read=EnumToString(CharacterID)>;
	}facultytraining<bgcolor=cBlack,name="Faculty ID">;
	
	FSeek(sectionpointers.PointerToSeminar);
	struct SeminarTraining{
		uint32 SeminarMagic;
		uint32 numSeminar;
		uint32 SizeOfSeminar;
		struct SeminarHeaderPadding{
			byte Padding[0x34];
		}seminarheaderpadding<name="Padding">;
		struct SeminarID{
			struct StatBitsSeminar{
				ubyte bit0 : 1<name="Sword">;
				ubyte bit1 : 1<name="Lances">;
				ubyte bit2 : 1<name="Axes">;
				ubyte bit3 : 1<name="Bows">;
				ubyte bit4 : 1<name="Brawling">;
				ubyte bit5 : 1<name="Reason">;
				ubyte bit6 : 1<name="Faith">;
				ubyte bit7 : 1<name="Authority">;
				ubyte bit8 : 1<name="Armor">;
				ubyte bit9 : 1<name="Riding">;
				ubyte bit10 : 1<name="Flying">;
				ubyte bit11 : 1<name="Reserve">;
				ubyte bit12 : 1<name="Reserve">;
				ubyte bit13 : 1<name="Reserve">;
				ubyte bit14 : 1<name="Reserve">;
				ubyte bit15 : 1<name="Reserve">;
			}statbitsseminar<name="Stats Interested">;
			CharID CharacterID<name="Character ID">;
			TrueFalse IsTeacher<name="IsTeacher">;
			byte padding;
		}seminarid[numSeminar]<name="Seminar Stuff", read=EnumToString(CharacterID)>;
	}seminartraining<bgcolor=cGreen,name="Seminar ID">;
	
	FSeek(sectionpointers.Size3Pointer);
	struct CharacterGoals{
		uint32 CharacterGoalsMagic;
		uint32 numCharacterGoals;
		uint32 SizeOfCharacterGoals;
		struct CharacterGoalsHeaderPadding{
			byte Padding[0x34];
		}charactergoalspadding<name="Padding">;
        local int count = 0;
        for (count = 0; count < 40; ++count){
		struct CharacterGoal{
            local CharID_Goals charID<hidden=true>;
            charID = count;
            UnitGoals Default_Goal<read=EnumToString(goal), name="Default Goal", comment="This is what the unit autoranks in when not recruited", bgcolor=cGray>;
            UnitGoals Other_Goal1<read=EnumToString(goal), name="Other Goal 1">;
            UnitGoals Other_Goal2<read=EnumToString(goal), name="Other Goal 2">;
            UnitGoals Other_Goal3<read=EnumToString(goal), name="Other Goal 3">;
            UnitGoals Other_Goal4<read=EnumToString(goal), name="Other Goal 4">;
            UnitGoals Other_Goal5<read=EnumToString(goal), name="Other Goal 5">;
            UnitGoals Other_Goal6<read=EnumToString(goal), name="Other Goal 6">;
            UnitGoals Other_Goal7<read=EnumToString(goal), name="Other Goal 7">;
		}charactergoals<name="Character Goals", read=EnumToString(charID)>;
        }
	}charactergoals<bgcolor=cDkRed,name="Character Goals">;
	
	FSeek(sectionpointers.PortraitsPointer);
	struct Portraits{
		uint32 PortraitsMagic;
		uint32 numPortraits;
		uint32 SizeOfPortraits;
		struct PortraitsHeaderPadding{
			byte Padding[0x34];
		}portraitsheaderpadding<name="Padding">;
		struct PortraitsID{
			uint16 unk1<name="Expression Neutral">;
			uint16 unk2<name="Expression Happy">;
			uint16 unk3<name="Expression Angry">;
			uint16 unk4<name="Expression Diappointed">;
			uint16 unk5<name="Expression ">;
			uint16 unk6<name="Expression ">;
			uint16 unk7<name="Expression ">;
			uint16 unk8<name="Expression ">;
			uint16 unk9<name="Expression ">;
			uint16 unk10<name="Expression ">;
			uint16 unk11<name="Expression ">;
			uint16 TimeSkip<name="Unknown Flag">;
		}portraitsid[numPortraits]<name="Face ID">;
	}portraits<bgcolor=cDkPurple,name="Portrait IDs">;

    FSeek(sectionpointers.PointerToSpellLearnset);
    struct SpellListStructure {
        uint SpellListMagic<bgcolor=cRed>;
        uint numSpellList<bgcolor=cRed>;
        uint SizeOfSpellList<bgcolor=cRed>;
        struct SpellListHeaderPadding {
            byte Padding[0x34];
        }spelllistheaderpadding<name="Padding", bgcolor=cBlue>;
        struct SPELLLIST{
            local uint s;
            for( s = 0; s < numSpellList; s++ )
            {
                struct SpellListData {
                    local CharID NameOfChar<hidden=true>;
                    NameOfChar = GetPlayableIndex(s); 
                    MinRanks FaithLearnLevel[5]<name="Faith Learnt Level", comment="0 = null">;
                    SpellID ReasonList[5]<name="Reason Spells">;
                    SpellID FaithList[5]<name="Faith Spells">;
                    MinRanks ReasonLearnLevel[5]<name="Reason Learnt Level", comment="0 = null">;
                }spelllistdata<name="Spell List Data", read=EnumToString(NameOfChar)>;
            }
        }SpellList<name="Spell List">;
    }spellliststructure<name="Spell List Table", bgcolor=cYellow>;

    FSeek(sectionpointers.PointerToSkillLearnset);
    struct SkillListStructure {
        uint SkillListMagic<bgcolor=cRed>;
        uint numSkillList<bgcolor=cRed>;
        uint SizeOfSpellList<bgcolor=cRed>;
        byte Padding[0x34];
        struct SKILLLIST {
            for( i = 0; i < numSkillList; i++)
            {
                struct SkillListData {
                    local CharID NameOfChar<hidden=true>;
                    NameOfChar = GetPlayableIndex(i); 
                    RankStats SkillLearn[20]<name="Special Skill Learn List">;
                    AbilityID PreTSPersonalSkill<name="Pre Time Skip Personal Skill">;
                    AbilityID PostTSPersonalSkill<name="Post Time Skip Personal Skill">;
                    AbilityID AbilitiesLearnt[20]<name="Abilities Learnt">;
                    MinRanks RankLearnt[20]<name="Rank Learnt at">;
                }skilllistdata<name="Skill List Data", read=EnumToString(NameOfChar)>;
            }
        }SkillList<name="Skill List">;
    }skillliststructure<name="Skill List Table", bgcolor=cLtYellow>;
	
	FSeek(sectionpointers.SizeFourPointer);
	struct SizeFour{
		uint32 SizeFourMagic;
		uint32 numSizeFour;
		uint32 SizeOfSizeFour;
		struct SizeFourHeaderPadding{
			byte Padding[0x34];
		}sizefourheaderpadding<name="Padding">;
		struct SizeFourID{
			CharID enemyName<name="Character">;
			AbilityID skillid<name="Skill ID">;
			byte pad<hidden=false>;
		}sizefourid[numSizeFour]<name="Enemy Personal Skills",read=EnumToString(enemyName)>;
	}sizefour<name="Enemy Personal Skills", bgcolor=cDkGreen>;

    FSeek(sectionpointers.PointerToArtLearnset);
    struct ArtLearnsetStruct{
        uint Magic<bgcolor=cRed>;
        uint numArtLearnset<bgcolor=cRed>;
        uint SizeOfArtLearnset<bgcolor=cRed>;
        ubyte Padding[0x34]<bgcolor=cBlue>;
        struct ArtLearnset {
            for( i = 0; i < numArtLearnset; i++)
            {
                struct ArtLearnsetData {
                    local CharID NameOfChar<hidden=true>;
                    NameOfChar = i;
                    CombatArtID ArtLearned[10]<name="Combat Art Learned">;
                    RankStats RequiredStat[10]<name="Required Stat">;
                    MinRanks RequiredRank[10]<name="Required Rank">;
                }artlearnsetdata<name="Combat Art Learnset Data", read=GetCharNames>;
            }
        }artlearnset<name="Combat Art Learnset", bgcolor=cYellow>;
    }artlearnsetstruct<name="Combat Art Learnset Table">;

    FSeek(sectionpointers.PointerToHiddenTalent);
    struct HiddenTalentStruct {
        uint Magic<bgcolor=cRed>;
        uint numHdnTal<bgcolor=cRed>;
        uint SizeOfHndTal<bgcolor=cRed>;
        ubyte Padding[0x34]<bgcolor=cBlue>;
            struct HiddenTalentData {
                CharID character<name="Character ID">;
                ubyte level<name="Required Exp">;
                RankStats requiredStat<name="Required Stat">;
                CombatArtID Art<name="Combat Art Learnt">;
                AbilityID Skill<name="Skill Learnt">;
            }hiddentalentdata[numHdnTal]<name="Hidden Talent Data", read=GetTalentNames>;
    }hiddentalentstruct<name="Hidden Talent Table", bgcolor=cYellow>;
	
	FSeek(sectionpointers.LinkedAttackPtr);
	struct UnkSect1{
		uint32 UnkSect1Magic;
		uint32 numUnkSect1;
		uint32 SizeOfUnkSect1;
		struct UnkSect1HeaderPadding{
			byte Padding[0x34];
		}UnkSect1headerpadding<name="Padding">;
		struct UnkSect1ID{
			byte unk1;
			byte unk2;
			byte unk3;
			byte unk4;
			byte unk5;
			byte unk6;
			byte unk7;
			byte unk8;
			byte unk9;
			byte unk10;
			byte hitn<name="No Support Hit">;
			byte hitc<name="C Support Hit">;
			byte hitb<name="B Support Hit">;
			byte hita<name="A Support Hit">;
			byte hits<name="S Support Hit">;
			byte avon<name="No Support Avo">;
			byte avoc<name="C Support Avo">;
			byte avob<name="B Support Avo">;
			byte avoa<name="A Support Avo">;
			byte avos<name="S Support Avo">;
			byte mtn<name="No Support Mt">;
			byte mtc<name="C Support Mt">;
			byte mtb<name="B Support Mt">;
			byte mta<name="A Support Mt">;
			byte mts<name="S Support Mt">;
		}unksect1id[numUnkSect1]<name="Linked Attack Data",optimize=false>;
	}unksect1<name="Linked Attacks (Generic)", bgcolor=cDkGreen>;
	
	FSeek(sectionpointers.LinkedAttackSpecialPtr);
	struct UnkSect2{
		uint32 UnkSect2Magic;
		uint32 numUnkSect2;
		uint32 SizeOfUnkSect2;
		struct UnkSect2HeaderPadding{
			byte Padding[0x34];
		}UnkSect2headerpadding<name="Padding">;
		struct UnkSect2ID{
			CharID NameID1<name="Name ID 1">;
			CharID NameID2<name="Name ID 2">;
			byte unk5;
			byte unk6;
			byte unk7;
			byte unk8;
			byte unk9;
			byte unk10;
			byte unk11;
			byte unk12;
			byte unk13;
			byte unk14;
			byte hitn<name="No Support Hit">;
			byte hitc<name="C Support Hit">;
			byte hitb<name="B Support Hit">;
			byte hita<name="A Support Hit">;
			byte hits<name="S Support Hit">;
			byte avon<name="No Support Avo">;
			byte avoc<name="C Support Avo">;
			byte avob<name="B Support Avo">;
			byte avoa<name="A Support Avo">;
			byte avos<name="S Support Avo">;
			byte mtn<name="No Support Mt">;
			byte mtc<name="C Support Mt">;
			byte mtb<name="B Support Mt">;
			byte mta<name="A Support Mt">;
			byte mts<name="S Support Mt">;
            byte unk30;
		}unksect2id[numUnkSect2]<name="Special Linked Attack Data", read=GetSupportPairs2, optimize=false>;
	}unksect2<name="Linked Attacks (Special)", bgcolor=cDkGreen>;
	
	FSeek(sectionpointers.SupportListPointer);
    struct SupportListTableStruct{
        uint Magic<bgcolor=cRed>;
        uint numSupportPairs<bgcolor=cRed>;
        uint SizeOfSupportPairs<bgcolor=cRed>;
        ubyte Padding[0x34]<bgcolor=cBlue>;
                struct SupportPairs{
                    ushort padding<hidden=false, bgcolor=cBlack>;
                    CharID NameOfChar1<name="Character 1", bgcolor=cLtBlue>;
                    CharID NameOfChar2<name="Character 2", bgcolor=cLtBlue>;
                    SupportRankByte cs<name="Cindered Shadows Support Rank", bgcolor=cPurple>;
                    byte NegativePointsMultiplier<comment="When support points gained are < 1, multiply them by this value">;
                    ubyte percentage<name="Support Gain Percentage Increase">;
                    struct SupportFlags{
				        ubyte bit0 : 1<name="Flag 0: Has S?">;
				        ubyte bit1 : 1<name="Flag 1: Has A+">;
				        ubyte bit2 : 1<name="Flag 2: Has A">;
				        ubyte bit3 : 1<name="Flag 3: Has B+">;
				        ubyte bit4 : 1<name="Flag 4: Has B">;
				        ubyte bit5 : 1<name="Flag 5: Has C+">;
				        ubyte bit6 : 1<name="Flag 6: Has C">;
				        ubyte bit7 : 1<name="Flag 7: S Rank with MByleth">;
                        ubyte bit8 : 1<name="Flag 8: S Rank with FByleth">;
				        ubyte bit9 : 1<name="Flag 9: Active?">;
				        ubyte bit10 : 1<name="Flag 10">;
				        ubyte bit11 : 1<name="Flag 11">;
				        ubyte bit12 : 1<name="Flag 12">;
				        ubyte bit13 : 1<name="Flag 13">;
				        ubyte bit14 : 1<name="Flag 14">;
				        ubyte bit15 : 1<name="Flag 15">;
                    }supportFlags<name="Flags?">;
            
            ubyte padding<hidden=true, bgcolor=cBlack>;
                }supportpairs[numSupportPairs]<name="Support Pair", read=GetSupportPairs>;
    }supportlisttablestruct<bgcolor=0x70c009, name="Support Pair Table">;
	
	FSeek(sectionpointers.UnkPointer04);
	struct SharedAbilitiesTableStruct{
		uint32 SharedAbilitiesMagic<bgcolor=cRed>;
		uint32 numSharedAbilities<bgcolor=cRed>;
		uint32 SizeOfSharedAbilities<bgcolor=cRed>;
		struct SharedAbilitiesHeaderPadding{
			byte Padding[0x34];
		}SharedAbilitiesheaderpadding<name="Padding">;
        for( i = 0; i < numSharedAbilities; i++ )
		{
		    struct SharedAbilitiesStruct{
                local MinRanks NameOfRank<hidden=true>;
			    NameOfRank = i;
			    CombatArtID NameOfArt<name="Sword Combat Art">;
			    CombatArtID NameOfArt<name="Lance Combat Art">;
			    CombatArtID NameOfArt<name="Axe Combat Art">;
			    CombatArtID NameOfArt<name="Bow Combat Art">;
			    CombatArtID NameOfArt<name="Gauntlet Combat Art">;
			    CombatArtID NameOfArt<name="Reason Combat Art">;
			    CombatArtID NameOfArt<name="Faith Combat Art">;
			    CombatArtID NameOfArt<name="Authority Combat Art">;
			    CombatArtID NameOfArt<name="Armor Combat Art">;
			    CombatArtID NameOfArt<name="Riding Combat Art">;
			    CombatArtID NameOfArt<name="Flying Combat Art">;
			    AbilityID NameOfAbility<name="Sword Ability">;
			    AbilityID NameOfAbility<name="Lance Ability">;
			    AbilityID NameOfAbility<name="Axe Ability">;
			    AbilityID NameOfAbility<name="Bow Ability">;
			    AbilityID NameOfAbility<name="Gauntlet Ability">;
			    AbilityID NameOfAbility<name="Reason Ability">;
			    AbilityID NameOfAbility<name="Faith Ability">;
			    AbilityID NameOfAbility<name="Authority Ability">;
			    AbilityID NameOfAbility<name="Armor Ability">;
			    AbilityID NameOfAbility<name="Riding Ability">;
			    AbilityID NameOfAbility<name="Flying Ability">;
		    }sharedabilitiesstruct<name="Shared Learnset Data", read=GetRankName, optimize=false>;
        }
	}unksect4<name="Shared Learnset Table", bgcolor=cDkGreen>;
	

}file<open=true>;

string ReadNameID(Person &p){ return EnumToString(p.Name); }

string GetName(SizeFourID& value)
{
    return EnumToString(value.charID);
}
string GetCharNames(ArtLearnsetData &i)
{
    return EnumToString(i.NameOfChar);
}
string GetCharNames2(SkillListData &i)
{
    return EnumToString(i.NameOfChar);
}
string GetCharNames3(SpellListData &i)
{
    return EnumToString(i.NameOfChar);
}
string GetTalentNames(HiddenTalentData &i)
{
    return EnumToString(i.character);
}
string GetCharNames4(WpnRankData &i)
{
    return EnumToString(i.NameOfChar);
}
string GetRankName(SharedAbilitiesStruct &i)
{
    return EnumToString(i.NameOfRank);
}

string GetSupportPairs(SupportPairs &i)
{
    string supportPairs = EnumToString(i.NameOfChar1) + " + " + EnumToString(i.NameOfChar2);
    if (supportPairs == "")
        return "";
    return supportPairs;
} 

string GetSupportPairs2(UnkSect2ID &i)
{
    string supportPairs = EnumToString(i.NameID1) + EnumToString(i.NameID2);
    if (supportPairs == "")
        return "";
    return EnumToString(i.NameID1) + " + " + EnumToString(i.NameID2);
} 

CharID GetPlayableIndex(uint16 i){
    if (i < 38){
       local CharID out = i;
        return out;

    }
    
    else if (i > 37){
        local CharID cID = i+ 1002;
        return cID;
    }
    local CharID cID_default = i;
    return cID_default;
}