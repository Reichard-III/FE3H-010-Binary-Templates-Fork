//------------------------------------------------
//--- 010 Editor v14.0 Binary Template
//
//        File: fixed_persondata.bt
//     Authors: DeathChaos, Moonling, Triabolical, ReichardTheThird
//     Version: 1.10
//     Purpose: Determines character learnsets, growths, magic, support pairs, etc.
//    Category: Reichard
//   File Mask: *fixed_persondata.bin
//    ID Bytes: 
//     History: 
//   1.10	2/16/25 ReichardTheThird Started taking over maintainance and updates from previous authors
//   1.09	2020-02-18  DeathCha0s - Fix AID blocks from 1.1.0, add base Battalion
//   1.08	2019-09-04  DeathChaos - Added Enemy Personal Skills
//   1.07	----------  Moonling -   Added Spell List and Skills
//   1.06	----------  DeathChaos - Added Starting Weapon Ranks and Proficiencies
//   1.05	----------  DeathChaos - Added Character Goals
//   1.04	----------  DeathChaos - Added Portrait IDs
//   1.03	----------  DeathChaos - Added Facculty Related stuff
//   1.02	----------  DeathChaos - Added Voice ID
//   1.01	----------  DeathChaos - Added AID
//   1.00	2019-08-05  DeathChaos - started this
//------------------------------------------------


//---------------------------------------------
// Includes
//---------------------------------------------
#include "Structs.bt"
LittleEndian();
local int i<hidden=true>;
struct File{
	FileSections Sections;
	
	FSeekNextSection(Sections);
	struct PersonStructure{ //0
		DataSection Header;
		Person person[Header.NumEntries]<read=ReadNameID, name="Character Block",open=true>;
	}personstructure<bgcolor=cRed, name="Character Blocks">;
	
	FSeekNextSection(Sections);
	struct AssetIDStructure{ //1
		DataSection Header;
		struct AssetID{
			int16 NGPlusHair<name="NG+ Hair?">;
			int16 TimeSkipHeadModel<name="Part 2 Head Model">;
			int16 TimeSkipPortrait<name="Part 2 Portraits">;
			int16 PreTimeSkipHead<name="Part 1 Head Model">;
			int16 PreTimeSkipPortrait<name="Part 1 Portrait">;
			int16 BodyModelTimeSkip<name="Part 2 Model">;
			int16 DLCOutfit<name="Post Sothis Fusion Asset ID (Flag Set)">;
			int16 BodyModelPreTimeSkip<name="Part 1 Model">;
			int16 AlternateStatePortrait<name="Alternate State Portrait (Constance)">;
		}assetid[Header.NumEntries]<bgcolor=cGreen,open=true>;
	}assetidstructure<bgcolor=cBlue, name="Asset IDs">;
	
	FSeekNextSection(Sections);
	struct VoiceIDStructure{ //2
		DataSection Header;
		struct VoiceID{
			uint16 voice;
			uint16 voice;
			uint16 voice;
			uint16 voice;
		}voiceid[Header.NumEntries]<open=true>;
	}voicestructure<bgcolor=cPurple, name="Voice IDs">;
	
	FSeekNextSection(Sections);
	struct WpnRankStructure{ //3
		DataSection Header;
		struct WpnRank{
			for( i = 0; i < Header.NumEntries; i++ ){	
				struct WpnRankData {
					local CharID name<hidden=true> = GetPlayableIndex(i);
					ubyte autolevels<name="Number of Timeskip Autolevels">;
					bf8 unk;
					PaletteID CharColor<name="Character Color">;
					ClassID defaultClass<name="Default Class">;
					ClassID certclass[4]<name="Pre-Certified Classes">;
					struct combatFlags {
						ubyte bit0 : 1<name="Default Class Mastered">;
						ubyte bit1 : 1<name="Certified Class Mastered 0">;
						ubyte bit2 : 1<name="Certified Class Mastered 1">;
						ubyte bit3 : 1<name="Certified Class Mastered 2">;
						ubyte bit4 : 1<name="Certified Class Mastered 3">;
						ubyte bit5 : 1<name="Unknown">;
						ubyte bit6 : 1<name="Unknown">;
						ubyte bit7 : 1<name="Minimum 2 Stat Level Ups">;
					}flags<name="Combat Related Flags">;
					StartingRanks StartWepRanks<name="Starting Weapon Ranks", bgcolor=cBlue>;
					WpnProficiency wpnproficiency<name="Proficiencies">;
					ClassID class<name="Post TimeSkip Unique Class">;
					ClassID class<name="Post TimeSkip Unique Class">;
					ClassID class<name="Post TimeSkip Unique Class">;
				}wpnrankdata<name="Wpn Ranks/Assets Data", read=EnumToString(name)>;
			}
		}wpnrank<name="Starting Weapon Ranks and Combat Assets",open=true>;
	}wpnrankstructure<bgcolor=cDkYellow, name="Starting Weapon Ranks and Combat Assets">;
	
	FSeekNextSection(Sections);
	struct SpellListStructure { //4
		DataSection Header;
		struct SPELLLIST{
			for( i = 0; i < Header.NumEntries; i++ ){
				struct SpellListData {
					local CharID NameOfChar<hidden=true> = GetPlayableIndex(i); 
					MinRanks FaithLearnLevel[5]<name="Faith Learnt Level", comment="0 = null">;
					SpellID ReasonList[5]<name="Reason Spells">;
					SpellID FaithList[5]<name="Faith Spells">;
					MinRanks ReasonLearnLevel[5]<name="Reason Learnt Level", comment="0 = null">;
				}spelllistdata<name="Spell List Data", read=EnumToString(NameOfChar)>;
			}
		}SpellList<name="Spell List",open=true>;
	}spellliststructure<name="Spell List Table", bgcolor=cYellow>;
	
	FSeekNextSection(Sections);
	struct SkillListStructure { //5
		DataSection Header;
		struct SKILLLIST {
			for( i = 0; i < Header.NumEntries; i++) {
				struct SkillListData {
					local CharID NameOfChar<hidden=true> = GetPlayableIndex(i); 
					RankStats SkillLearn[20]<name="Special Skill Learn List">;
					AbilityID PreTSPersonalSkill<name="Pre Time Skip Personal Skill">;
					AbilityID PostTSPersonalSkill<name="Post Time Skip Personal Skill">;
					AbilityID AbilitiesLearnt[20]<name="Abilities Learnt">;
					MinRanks RankLearnt[20]<name="Rank Learnt at">;
				}skilllistdata<name="Skill List Data", read=EnumToString(NameOfChar)>;
			}
		}SkillList<name="Skill List",open=true>;
	}skillliststructure<name="Skill List Table", bgcolor=cLtYellow>;
	
	FSeekNextSection(Sections);
	struct StartingWeaponsStructure{ //6
		DataSection Header;
		for (i = 0; i < Header.NumEntries; i++){
			struct StartWepID{
				local CharID NameOfChar<hidden=true> = GetPlayableIndex(i); 
				int16 Flag<name="Item Flag?">;
				Item Weapon1<name="Item Slot 1">;
				Item Weapon2<name="Item Slot 2">;
				Item Weapon3<name="Item Slot 3">;
				Item Weapon4<name="Item Slot 4">;
				Item Weapon5<name="Item Slot 5">;
				Item Weapon6<name="Item Slot 6">;
			}startwepid<name="Starting Inventory", read=EnumToString(NameOfChar)>;
		}
	}startingweaponsstructure<bgcolor=cDkBlue, name="Starting Weapons">;
	
	FSeekNextSection(Sections);
	struct ArtLearnsetStruct{ //7
		DataSection Header;
		struct ArtLearnset {
			for( i = 0; i < Header.NumEntries; i++){
				struct ArtLearnsetData {
					local CharID NameOfChar<hidden=true> = i;
					CombatArtID ArtLearned[10]<name="Combat Art Learned">;
					RankStats RequiredStat[10]<name="Required Stat">;
					MinRanks RequiredRank[10]<name="Required Rank">;
				}artlearnsetdata<name="Combat Art Learnset Data", read=GetCharNames>;
			}
		}artlearnset<name="Combat Art Learnset", bgcolor=cYellow,open=true>;
	}artlearnsetstruct<name="Combat Art Learnset Table">;
	
	FSeekNextSection(Sections);
	struct UnkSect1{ //8
		DataSection Header;
		struct UnkSect1ID{
			byte unk1;
			byte unk2;
			byte unk3;
			byte unk4;
			byte unk5;
			byte unk6;
			byte unk7;
			byte unk8;
			byte unk9;
			byte unk10;
			byte hitn<name="No Support Hit">;
			byte hitc<name="C Support Hit">;
			byte hitb<name="B Support Hit">;
			byte hita<name="A Support Hit">;
			byte hits<name="S Support Hit">;
			byte avon<name="No Support Avo">;
			byte avoc<name="C Support Avo">;
			byte avob<name="B Support Avo">;
			byte avoa<name="A Support Avo">;
			byte avos<name="S Support Avo">;
			byte mtn<name="No Support Mt">;
			byte mtc<name="C Support Mt">;
			byte mtb<name="B Support Mt">;
			byte mta<name="A Support Mt">;
			byte mts<name="S Support Mt">;
		}unksect1id[Header.NumEntries]<name="Linked Attack Data",optimize=false,open=true>;
	}unksect1<name="Linked Attacks (Generic)", bgcolor=cDkGreen>;
	
	FSeekNextSection(Sections);
	struct UnkSect2{ //9
		DataSection Header;
		struct UnkSect2ID{
			CharID NameID1<name="Name ID 1">;
			CharID NameID2<name="Name ID 2">;
			byte unk5;
			byte unk6;
			byte unk7;
			byte unk8;
			byte unk9;
			byte unk10;
			byte unk11;
			byte unk12;
			byte unk13;
			byte unk14;
			byte hitn<name="No Support Hit">;
			byte hitc<name="C Support Hit">;
			byte hitb<name="B Support Hit">;
			byte hita<name="A Support Hit">;
			byte hits<name="S Support Hit">;
			byte avon<name="No Support Avo">;
			byte avoc<name="C Support Avo">;
			byte avob<name="B Support Avo">;
			byte avoa<name="A Support Avo">;
			byte avos<name="S Support Avo">;
			byte mtn<name="No Support Mt">;
			byte mtc<name="C Support Mt">;
			byte mtb<name="B Support Mt">;
			byte mta<name="A Support Mt">;
			byte mts<name="S Support Mt">;
			byte unk30;
		}unksect2id[Header.NumEntries]<name="Special Linked Attack Data", read=GetSupportPairs2, optimize=false,open=true>;
	}unksect2<name="Linked Attacks (Special)", bgcolor=cDkGreen>;
	
	FSeekNextSection(Sections);
	struct SupportListTableStruct{ //10
		DataSection Header;
		struct SupportPairs{
			ushort padding<hidden=false, bgcolor=cBlack>;
			CharID NameOfChar1<name="Character 1", bgcolor=cLtBlue>;
			CharID NameOfChar2<name="Character 2", bgcolor=cLtBlue>;
			SupportRankByte cs<name="Cindered Shadows Support Rank", bgcolor=cPurple>;
			byte NegativePointsMultiplier<comment="When support points gained are < 1, multiply them by this value">;
			ubyte percentage<name="Support Gain Percentage Increase">;
			struct SupportFlags{
				ubyte bit0 : 1<name="Flag 0: Has S?">;
				ubyte bit1 : 1<name="Flag 1: Has A+">;
				ubyte bit2 : 1<name="Flag 2: Has A">;
				ubyte bit3 : 1<name="Flag 3: Has B+">;
				ubyte bit4 : 1<name="Flag 4: Has B">;
				ubyte bit5 : 1<name="Flag 5: Has C+">;
				ubyte bit6 : 1<name="Flag 6: Has C">;
				ubyte bit7 : 1<name="Flag 7: S Rank with MByleth">;
				ubyte bit8 : 1<name="Flag 8: S Rank with FByleth">;
				ubyte bit9 : 1<name="Flag 9: Active?">;
				ubyte bit10 : 1<name="Flag 10">;
				ubyte bit11 : 1<name="Flag 11">;
				ubyte bit12 : 1<name="Flag 12">;
				ubyte bit13 : 1<name="Flag 13">;
				ubyte bit14 : 1<name="Flag 14">;
				ubyte bit15 : 1<name="Flag 15">;
			}supportFlags<name="Flags?">;
			ubyte padding<hidden=true, bgcolor=cBlack>;
		}supportpairs[Header.NumEntries]<name="Support Pair", read=GetSupportPairs,open=true>;
	}supportlisttablestruct<bgcolor=0x70c009, name="Support Pair Table">;
	
	FSeekNextSection(Sections);
	struct HiddenTalentStruct { //11
		DataSection Header;
		struct HiddenTalentData {
			CharID character<name="Character ID">;
			ubyte level<name="Required Exp">;
			RankStats requiredStat<name="Required Stat">;
			CombatArtID Art<name="Combat Art Learnt">;
			AbilityID Skill<name="Skill Learnt">;
		}hiddentalentdata[Header.NumEntries]<name="Hidden Talent Data", read=GetTalentNames,open=true>;
	}hiddentalentstruct<name="Hidden Talent Table", bgcolor=cYellow>;
		
	FSeekNextSection(Sections);
	struct SharedAbilitiesTableStruct{ //12
		DataSection Header;
		for( i = 0; i < Header.NumEntries; i++ ){
			struct SharedAbilitiesStruct{
				local MinRanks NameOfRank<hidden=true> = i;
				CombatArtID NameOfArt<name="Sword Combat Art">;
				CombatArtID NameOfArt<name="Lance Combat Art">;
				CombatArtID NameOfArt<name="Axe Combat Art">;
				CombatArtID NameOfArt<name="Bow Combat Art">;
				CombatArtID NameOfArt<name="Gauntlet Combat Art">;
				CombatArtID NameOfArt<name="Reason Combat Art">;
				CombatArtID NameOfArt<name="Faith Combat Art">;
				CombatArtID NameOfArt<name="Authority Combat Art">;
				CombatArtID NameOfArt<name="Armor Combat Art">;
				CombatArtID NameOfArt<name="Riding Combat Art">;
				CombatArtID NameOfArt<name="Flying Combat Art">;
				AbilityID NameOfAbility<name="Sword Ability">;
				AbilityID NameOfAbility<name="Lance Ability">;
				AbilityID NameOfAbility<name="Axe Ability">;
				AbilityID NameOfAbility<name="Bow Ability">;
				AbilityID NameOfAbility<name="Gauntlet Ability">;
				AbilityID NameOfAbility<name="Reason Ability">;
				AbilityID NameOfAbility<name="Faith Ability">;
				AbilityID NameOfAbility<name="Authority Ability">;
				AbilityID NameOfAbility<name="Armor Ability">;
				AbilityID NameOfAbility<name="Riding Ability">;
				AbilityID NameOfAbility<name="Flying Ability">;
			}sharedabilitiesstruct<name="Shared Learnset Data", read=GetRankName, optimize=false>;
		}
	}unksect4<name="Shared Learnset Table", bgcolor=cDkGreen>;
		
	FSeekNextSection(Sections);
	struct FacultyTraining{ //13
		DataSection Header;
		struct FacultyID{
			StatBits statbits<name="Teachable Stats">;
			CharID CharacterID<name="Character ID">;
			TrueFalse IsTeacher<name="IsTeacher">;
			byte padding;
		}facultyid[Header.NumEntries]<name="Faculty Training Stuff", read=EnumToString(CharacterID),open=true>;
	}facultytraining<bgcolor=cBlack,name="Faculty ID">;
	
	FSeekNextSection(Sections);
	struct SeminarTraining{ //14
		DataSection Header;
		struct SeminarID{
			struct StatBitsSeminar{
				ubyte bit0 : 1<name="Sword">;
				ubyte bit1 : 1<name="Lances">;
				ubyte bit2 : 1<name="Axes">;
				ubyte bit3 : 1<name="Bows">;
				ubyte bit4 : 1<name="Brawling">;
				ubyte bit5 : 1<name="Reason">;
				ubyte bit6 : 1<name="Faith">;
				ubyte bit7 : 1<name="Authority">;
				ubyte bit8 : 1<name="Armor">;
				ubyte bit9 : 1<name="Riding">;
				ubyte bit10 : 1<name="Flying">;
				ubyte bit11 : 1<name="Reserve">;
				ubyte bit12 : 1<name="Reserve">;
				ubyte bit13 : 1<name="Reserve">;
				ubyte bit14 : 1<name="Reserve">;
				ubyte bit15 : 1<name="Reserve">;
			}statbitsseminar<name="Stats Interested">;
			CharID CharacterID<name="Character ID">;
			TrueFalse IsTeacher<name="IsTeacher">;
			byte padding;
		}seminarid[Header.NumEntries]<name="Seminar Stuff", read=EnumToString(CharacterID),open=true>;
	}seminartraining<bgcolor=cGreen,name="Seminar ID">;
	
	FSeekNextSection(Sections);
	struct CharacterGoals{ //15
		DataSection Header;
		local int count = 0;
		for (count = 0; count < 40; ++count){
			struct CharacterGoal{
				local CharID_Goals charID<hidden=true> = count;
				UnitGoals Default_Goal<read=EnumToString(goal), name="Default Goal", comment="This is what the unit autoranks in when not recruited", bgcolor=cGray>;
				UnitGoals Other_Goal1<read=EnumToString(goal), name="Other Goal 1">;
				UnitGoals Other_Goal2<read=EnumToString(goal), name="Other Goal 2">;
				UnitGoals Other_Goal3<read=EnumToString(goal), name="Other Goal 3">;
				UnitGoals Other_Goal4<read=EnumToString(goal), name="Other Goal 4">;
				UnitGoals Other_Goal5<read=EnumToString(goal), name="Other Goal 5">;
				UnitGoals Other_Goal6<read=EnumToString(goal), name="Other Goal 6">;
				UnitGoals Other_Goal7<read=EnumToString(goal), name="Other Goal 7">;
			}charactergoals<name="Character Goals", read=EnumToString(charID)>;
		}
	}charactergoals<bgcolor=cDkRed,name="Character Goals">;
	
	FSeekNextSection(Sections);
	struct Portraits{ //16
		DataSection Header;
		struct PortraitsID{
			uint16 unk1<name="Expression Neutral">;
			uint16 unk2<name="Expression Happy">;
			uint16 unk3<name="Expression Angry">;
			uint16 unk4<name="Expression Diappointed">;
			uint16 unk5<name="Expression ">;
			uint16 unk6<name="Expression ">;
			uint16 unk7<name="Expression ">;
			uint16 unk8<name="Expression ">;
			uint16 unk9<name="Expression ">;
			uint16 unk10<name="Expression ">;
			uint16 unk11<name="Expression ">;
			uint16 TimeSkip<name="Unknown Flag">;
		}portraitsid[Header.NumEntries]<name="Face ID",open=true>;
	}portraits<bgcolor=cDkPurple,name="Portrait IDs">;
	
	FSeekNextSection(Sections);
	struct SizeFour{ //17
		DataSection Header;
		struct SizeFourID{
			CharID enemyName<name="Character">;
			AbilityID skillid<name="Skill ID">;
			byte pad<hidden=false>;
		}sizefourid[Header.NumEntries]<name="Enemy Personal Skills",read=EnumToString(enemyName),open=true>;
	}sizefour<name="Enemy Personal Skills", bgcolor=cDkGreen>;
}file<open=true>;

string ReadNameID(Person &p){                 return EnumToString(p.Name); }
string GetName(SizeFourID& value){            return EnumToString(value.charID); }
string GetCharNames(ArtLearnsetData &i){      return EnumToString(i.NameOfChar); }
string GetCharNames2(SkillListData &i){       return EnumToString(i.NameOfChar); }
string GetCharNames3(SpellListData &i){       return EnumToString(i.NameOfChar); }
string GetTalentNames(HiddenTalentData &i){   return EnumToString(i.character); }
string GetCharNames4(WpnRankData &i){         return EnumToString(i.NameOfChar); }
string GetRankName(SharedAbilitiesStruct &i){ return EnumToString(i.NameOfRank); }

string GetSupportPairs(SupportPairs &i){
	string supportPairs = EnumToString(i.NameOfChar1) + " + " + EnumToString(i.NameOfChar2);
	if (supportPairs == "")
		return "";
	return supportPairs;
} 

string GetSupportPairs2(UnkSect2ID &i){
	string supportPairs = EnumToString(i.NameID1) + EnumToString(i.NameID2);
	if (supportPairs == "")
		return "";
	return EnumToString(i.NameID1) + " + " + EnumToString(i.NameID2);
} 

CharID GetPlayableIndex(uint16 i){
	if (i > 37) return (CharID)(i+1002);
	return (CharID) i;
}