//------------------------------------------------
//--- 010 Editor v14.0 Binary Template
//
//      File: fixed_classdata.bt
//   Authors: RayTwo?, DeathChaos?, TildeHat, Moonling, Puddles, Triabolical, ReichardTheThird
//   Version: 1.07
//   Purpose: Parameters for classes
//  Category: Reichard
// File Mask: *fixed_classdata.bin
//  ID Bytes: 
//   History: 
//   1.07    3/9/25 ReichardTheThird: Changed Unk_Short[17] to MonsterHPBarScaling_Short[15] + Unk_Short[2]
//   1.06    3/2/25 ReichardTheThird: Rearranged MonsterClass in struct order as it is written in memory
//                                  {Item[5], Other Data, Drop Quantity[5], Drop Chance[5]}
//                                  rather than logical order
//                                  {Item[0] = {Item[0], Drop Quantity[0], Drop Chance[0]}, ..., Item[4], Other Data}
//   1.05    2/16/25 ReichardTheThird: Started taking over maintainance and updates from previous authors
//   1.04    2019-09-14  Puddles - added mapping to class arts
//   1.03    2019-09-13  Moonling - added reclassing item
//   1.02    2019-09-11  TildeHat - added mapping to class data and abilities
//   1.01    2019-08-28  DeathChaos - added class names to struct indices
//   1.00    2019-08-28  DeathChaos - started this
//------------------------------------------------

//---------------------------------------------
// Includes
//---------------------------------------------

#include "Structs.bt"
enum<ubyte> GenderFlags {
    Only_Males = 0,
    Only_Females,
    Both_Genders,
};

enum<ubyte> CertificationFlag {
    Cannot_Cert = 0,
    Can_Cert = 1,
    Byleth_Maybe = 2,
    Dance_Mayber = 3,
};

LittleEndian();
local int i;
local int j;

struct File{
    FileSections Headers;
    
    FSeekNextSection(Headers);
	struct ClassData{ //0
        DataSection SectionHeader;
        for( i = 0; i < SectionHeader.NumEntries; i++ ){
            struct ClassBlock{
                local ClassID Class<hidden=true> = i;
                short CameraFrame[4];
                AID MaleAID;
                AID FemaleAID;
                uint16 Zoo;
                uint16 UnknownValue;
                byte HPBonus;
                MountID mount<name="Mount ID?">;
                Adjutant adjutantType<name="Adjutant Type">;
                byte EnemyHPGrowth<name="Enemy HP Growth">;
                struct PlayerGrowths{  
                    byte HPGrowth<name="HP Growth">;
                    byte StrGrowth<name="Str Growth">;
                    byte MagGrowth<name="Mag Growth">;
                    byte DexGrowth<name="Dex  Growth">;
                    byte SpdGrowth<name="Spd Growth">;
                    byte LckGrowth<name="Lck Growth">;
                    byte DefGrowth<name="Def Growth">;
                    byte ResGrowth<name="Res Growth">;
                    byte MovGrowth<name="Mov Growth">;
                    byte CharmGrowth<name="Cha Growth">;
                }playergrowths<bgcolor=cDkYellow>;
                Stats EnemyGrowths<name="Enemy Growth Rates">;
                Stats Class_Modifiers<name="Class Modifiers">;
                Stats Mounted_Modifiers<name="Mounted Stat Modifiers">;
                struct RankBonus{
                    byte SwordExp<name="Sword Exp">;
                    byte LanceExp<name="Lance Exp">;
                    byte AxeExp<name="Axe Exp">;
                    byte BowExp<name="Bow Exp">;
                    byte BrawlingExp<name="Brawling Exp">;
                    byte ReasonExp<name="Reason Exp">;
                    byte FaithExp<name="Faith Exp">;
                    byte AuthorityExp<name="Authority Exp">;
                    byte ArmorExp<name="Heavy Armor Exp">;
                    byte RidingExp<name="Riding Exp">;
                    byte FlyingExp<name="Flying Exp">;
                }rankbonus<name="Rank Bonus">;
                EquipID ShieldID<name="Class Equipped Item">;
                ClassTier tier<name="Class Certification Tier">;
                byte MountMapScale<name="Mount Map Scale">;
                byte UnitMapScale<name="Unit Map Scale">;
                ubyte UnknownValue;
                byte monsterID<name="Monster Index in Monster Block">;
                ubyte classMastery<name="Class Exp Requirement">;
                byte BaseHP<name="Base HP">;
                ubyte expcCoeff<name="Exp Yield Coeff">;
                MoveType Movement1<name="Movement Restricted">;
                MoveType Movement2<name="Movement Restricted Dismounted">;
                WeaponType weapon1<name="Enemy Weapon Type 1">;
                WeaponType weapon2<name="Enemy Weapon Type 2">;
                ClassClassification effectiveness<name="Class Effectiveness">;
                ClassProperty classproperty<name="Class Property", bgcolor=cYellow>;
                SpellID Spell1<name="Enemy Spell 1">;
                SpellID Spell2<name="Enemy Spell 2">;
                Stats BaseStats<name="Class Base Stats">;
                CombatArtID RandomlyAssignedCombatArt[4]<bgcolor=cWhite,comment="randomly assigns unit one of these combat arts, Hard mode selects from the first 2 entries, Maddening selects from all 4 entries, Hard mode only assigns CAs 50% of the time even if all 2 slots filled">;
                EnemyAbilities Cindered_Shadows_Normal<name="Cindered Shadows Normal?", bgcolor=cLtGreen>;
                EnemyAbilities Cindered_Shadows_Hard<name="Cindered Shadows Hard?", bgcolor=cDkRed>;
                EnemyAbilities Hard_Mode<name="Hard Mode Abilities", bgcolor=cLtRed>;
                EnemyAbilities Maddening_Mode<name="Maddening Mode Abilities", bgcolor=cPurple>;
            }classdata<bgcolor=cDkBlue,name="Class Data",read=EnumToString(Class)>;    
        }
    }classBlock<bgcolor=cDkBlue,name="Class Block">;

	FSeekNextSection(Headers);
	struct GenderLock { //1
		DataSection SectionHeader;		
		struct Requirements{
            for( i = 0; i < SectionHeader.NumEntries; i++ ) {
                struct GenderLockID {
                    local ClassID Class<hidden=true> = i;
                    ubyte examScaling<name="Certifcation Scaling Factor", bgcolor=cLtRed, comment="Pass% = 100 - Certifcation Scaling Factor x N Missing Ranks">;
                    ConsumablesByte RequiredItem<name="Item Need for Certification", bgcolor=cLtBlue>;
                    CertificationFlag certifiable<name="Certification Flag", bgcolor=cBlack, comment="Some classes cannot be able to cert regardless of flag">;
                    GenderFlags flag<name="Gender Flags", bgcolor=cBlack>;
                    MinRanks rank0<name="Minimum Sword Requirement", comment="Default Ranks in class">;
                    MinRanks rank1<name="Minimum Lances Requirement", comment="Default Ranks in class">;
                    MinRanks rank2<name="Minimum Axes Requirement", comment="Default Ranks in class">;
                    MinRanks rank3<name="Minimum Bows Requirement", comment="Default Ranks in class">;
                    MinRanks rank4<name="Minimum Brawling Requirement", comment="Default Ranks in class">;
                    MinRanks rank5<name="Minimum Reason Requirement", comment="Default Ranks in class">;
                    MinRanks rank6<name="Minimum Faith Requirement", comment="Default Ranks in class">;
                    MinRanks rank7<name="Minimum Authority Requirement", comment="Default Ranks in class">;
                    MinRanks rank8<name="Minimum Armor Requirement", comment="Default Ranks in class">;
                    MinRanks rank9<name="Minimum Riding Requirement", comment="Default Ranks in class">;
                    MinRanks rank10<name="Minimum Flying Requirement", comment="Default Ranks in class">;
				}genderlockid<name="Class Requirements",read=EnumToString(Class)>;
            }
		}requirements<name="Class Requirements">;
	}classReqs<bgcolor=cDkGreen,name="Certification Requirements", comment="Default Ranks. Only 3 of them can be used. Rest of the ranks will be ignored.">;
    
    FSeekNextSection(Headers);
	struct TierLevel { //2
        DataSection SectionHeader;
        ubyte Zero<bgcolor=cWhite>;
        ubyte Beginner<bgcolor=cWhite>;
        ubyte Intermediate<bgcolor=cWhite>;
        ubyte Advanced<bgcolor=cWhite>;
        ubyte Master<bgcolor=cWhite>;
        ubyte Special<bgcolor=cWhite>;
        ubyte Unique<bgcolor=cWhite>;
        byte padding<hidden=true>;
    }tierlevel<bgcolor=cDkRed,name="Tier Level Requirements">;
    
    FSeekNextSection(Headers);
	struct ClassAbility { //3
		DataSection SectionHeader;
        for( i = 0; i < SectionHeader.NumEntries; i++ )
            struct AbilityBlock{
                local ClassID Class<hidden=true> = i;
		        AbilityID MasteredAbility<name="Mastered Ability", bgcolor=cBlue>;
                CombatArtID MasterArt<name="Mastered Combart Art", bgcolor=cBlue>;
                AbilityID ClassAbility1<name="Class Ability", bgcolor=cGreen>;
                AbilityID ClassAbility2<name="Class Ability", bgcolor=cGreen>;
                AbilityID ClassAbility3<name="Class Ability", bgcolor=cGreen>;
		}classblock<name="Ability Block",read=MyStructToStringA>;
	}classabilities<bgcolor=cDkBlue,name="Class Abilities">;
    
    FSeekNextSection(Headers);
    struct MonsterBlock { //4
        DataSection SectionHeader;
        for (i = 0; i < SectionHeader.NumEntries; ++i){
            struct MonsterClassData {
                local MonsterName name<hidden=true> = i;
                ushort unk<bgcolor=cBlack>;
                ushort unk<bgcolor=cBlack>;
                WeaponID weapon<name="Monster's Equipped Weapon", bgcolor=cBlue>;
                struct BarrierDrops {
                    for (j = 0; j < 5; j++){
                        struct BarrierItem{
                            MiscItem barrierDrop<name="Item", bgcolor=cLtGreen>;
                            ubyte padding<hidden=false, name="unknown padding?",bgcolor=cLtGreen>;
                        }Bitem<name="Barrier Item", name=ReadBarrierItem, bgcolor=cLtGreen>;
                    };
                }barrierItems<name="Barrier Items">;
                struct MonsterHPBarScalingByDifficulty {
                    for(j = 0; j<3;++j){
                        struct MonsterHPBarScaling { 
                            local Difficulty diff = j;
                            local string diffName = EnumToString(diff);
                            diffName = StrDel(diffName, Strlen(diffName)-2, 2);
                            short a0<name="0 missing HP bars">;
                            short a1<name="1 missing HP bars">;
                            short a2<name="2 missing HP bars">;
                            short a3<name="3 missing HP bars">;
                            short a4<name="4 missing HP bars">;
                        }monsterHPScaling<name="Difficulty Level", read=diffName, open=true>;
                    }
                }monsterHPScalingByDiff<name="Monster HP Bar Scaling">;
                short unknown[2];
                ubyte barrierDamageReductionk<name="Barrier Damage Reduction %", bgcolor=cWhite>;
                BarrierStatus bstatus<name="Default Barrier Status", bgcolor=cBlue>;
                ubyte numberHP<name="Number of HP bars", bgcolor=cDkGreen>;
                ubyte BarrierText<name="Barrier Text Index", bgcolor=cDkYellow>;
                StaggeringBlow Staggering<name="Staggering Blow", bgcolor=cRed>;
                ubyte MonsterScale<name="Monster Scale">;
                MonsterSize size<name="Monster Tile Size">;
                ubyte unk;
                ubyte AllowLatentAbilities<comment="When enabled, this allows Monsters to gain Latent Abilities">;
                ubyte unk2<comment="This data was not actually covered by the original BT, need to investigate">;
                struct LatentAbilityBlock {
                    ubyte latent[4]<name="Activation HP Bar", bgcolor=cDkYellow>;
                    AbilityID latentAbility[4]<name="Latent Ability", bgcolor=cDkYellow>;
                }latentBlock<name="Latent Ability Data">;
                struct BarrierAbilities {
                    AbilityID barrierAbility<name="Barrier Ability", bgcolor=cBlack>;
                    AbilityID barrierAbility<name="Barrier Ability", bgcolor=cBlack>;
                }barrier<name="Barrier Ability List">;
                ubyte n_item[5]<name="BarrierItem Drop Quantity", bgcolor=cLtGreen>;
                ubyte rate_item[5]<name="BarrierItem Drop chance">;
            }monsterClass<read=EnumToString(name), name="Monster Class Data">;
        }
    }monsterBlock<name="Monster Class Block">;
    
    FSeekNextSection(Headers);
    GenericSection UnkSection1<name="Camera-Related">; //5
    
    FSeekNextSection(Headers);
    GenericSection UnkSection2<name="Camera-Related">; //6
    
    FSeekNextSection(Headers);
    struct sClassPreviews{ //7
        DataSection SectionHeader;
        for(i=0;i<SectionHeader.NumEntries;i++){
            struct sClassPreview{
                ubyte CameraAngleOffset<comment="Clockwise: degrees offset from the Quadrant line">;
                ubyte CameraQuadrant<comment="0 = North +0 deg, 1 = East +90 deg, 2 = South +180 deg, 3 = West +270 deg">;
                CharID Character;
                ushort Rotation<comment="determines the angle the unit is facing on the map">;
                ScenarioName Scenario;
                ClassID DefaultClass<name="Default Class?">;
                MapList map;
                ClassID Class<name="TimeSkip Class?">;
                MinRanks ReasonRank<name="Reason Rank">;
                byte X;
                byte Y;
                MinRanks FaithRank<name="Faith Rank">;
            }ClassPreview<name="Class Preview">;
        }    
    }ClassPreviews<name="Class Previews",comment="Determines the showcase of unit/classes when idling in the main menu">;
    
    FSeekNextSection(Headers);
    struct sSection9{ //8
        DataSection SectionHeader;
        for(i=0;i<SectionHeader.NumEntries;i++){
            struct sdata9{
                ushort unkshort0x0;
                ushort unkshort0x2;
            }data9;
        }
    }UnknownSection8;
    
    FSeekNextSection(Headers);
    struct Section10{ //9
        DataSection SectionHeader;
        for (i = 0; i < SectionHeader.NumEntries; ++i){
            struct Data10{
                local ClassID Class<hidden=true> = i;
                ClassID class1;
                ClassID class2;
                ClassID class3;
                ClassID class4;
            }someEntry<read=EnumToString(Class)>;
        }
    }UnknownSection9<bgcolor=cLtBlue>;
}file<open=true>;

string MyStructToStringA(AbilityBlock& value) { return EnumToString(value.Class); }
string MyStructToStringC(ClassBlock& value) {   return EnumToString(value.Class); }
string ReadBarrierItem(BarrierItem& value) {    return SPrintf(str, "%s", EnumToString(value.barrierDrop)); }