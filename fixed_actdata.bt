//------------------------------------------------
//--- 010 Editor v14.0 Binary Template
//
//      File: fixed_actdata.bt
//   Authors: RayTwo?, DeathChaos?, Triabolical, ReichardTheThird
//   Version: 1.0
//   Purpose: Parameters for animations
//  Category: Reichard
// File Mask: *fixed_act_data.bin
//  ID Bytes: 
//   History: 
//   1.0    2/16/25 ReichardTheThird: Started taking over maintainance and updates from previous authors
//------------------------------------------------

#include "Structs.bt"

struct CharacterAnimations {
    DataSection sectionHeader<name="Section Header">;
    struct CharacterActBlock{
        ModelIDInt character<name="Character/Mount", bgcolor=cDkGreen>;
        ModelIDInt character2<name="Character", bgcolor=cDkGreen>;
        Animation act1<name="Animation Set", bgcolor=cLtRed>;
        Animation act2<name="Animation Set", bgcolor=cLtRed>;
        TrueFalse EnableClass<name="Enable for Class">; 
        ClassID class<name="Class">;
        TrueFalse Enabled<name="Enabled with Weapon">;
        ClassType classType<name="Class Type", bgcolor=cBlack>;
        MountAnimation mount1<name="Mount-Related", bgcolor=cDkBlue>;   
        MountAnimation mount2<name="Mount-Related", bgcolor=cDkBlue>;        
        WeapAnimType Weapon<name="Weapon Type", bgcolor=cBlack>; 
        byte Padding<hidden=false>;
    }unkData[sectionHeader.NumEntries]<name="Character Animation", bgcolor=cLtBlue, read=GetSection1Name>;
};

struct ReactionAnimations{
    DataSection sectionHeader<name="Section Header">;
    struct Entry5{
        Animation animation<bgcolor=cBlack, name="Animation Set">;
        Animation animation<bgcolor=cBlack, name="Animation Set">;
        Gender gender<name="Gender">;
        ClassType classType<name="Class Type", bgcolor=cBlack>;
        MountAnimation mount1<name="Mount-Related", bgcolor=cDkBlue>;   
        MountAnimation mount2<name="Mount-Related", bgcolor=cDkBlue>;        
    }unkData[sectionHeader.NumEntries]<name="Reaction Animation", bgcolor=cLtBlue>;
};

struct IdleAnimations {
    DataSection sectionHeader<name="Section Header">;
    for (m = 0; m < sectionHeader.NumEntries; m++)
        Animation attack<name="Animation">;
};

struct ClassBaseAnim{
    DataSection sectionHeader<name="Section Header">;
    struct ClassBaseAnimData {
        Animation animation<bgcolor=cBlack, name="Animation Set">;
        short unknown<bgcolor=cRed, name="Index?">;
        Gender gender<name="Gender">;
        ClassType classType<name="Class Type", bgcolor=cBlack>;
        TrueFalse Enabled<name="Is Enable">;
        WeapAnimType Weapon<name="Weapon Type", bgcolor=cGreen>; 
        MountAnimation mount1<name="Mount Animation", bgcolor=cBlue>;
        ubyte mount2<name="Mount Animation", bgcolor=cBlue>;
    }classbaseanimdata[sectionHeader.NumEntries]<name="Base Animations", read=BaseAnimationName, bgcolor=cLtBlue>;
};

LittleEndian();
local int i;
local int m = 0;
struct FILE {
    FileSections Section<name="File Headers">;
    
	CharacterAnimations block0<name="Character Animation Block">; //0
	
    struct ClassUniAnim{ //1
        DataSection sectionHeader<name="Section Header">;
		struct ClassUniAnimData{
			Animation AnimSet1<name="Unknown Animations", bgcolor=cDkGreen>;
			Animation MainAnim<name="Main Animations", bgcolor=cDkGreen>;
            MountAnimation mount1<name="Mount Animation", bgcolor=cBlue>;
            ubyte mount2<name="Mount Animation", bgcolor=cBlue>;
			ClassID Class<name="Class", bgcolor=cLtBlue>;
			ClassType type<name="Class Type", bgcolor=cBlack>;
			TrueFalse Enabled<name="For Specific Weapon Type", bgcolor=cRed>;
			WeapAnimType Weapon<name="Weapon Type", bgcolor=cGreen>; 
			Gender gender<name="Gender">;
			byte unk<hidden=false>;
		}classunianimdata[sectionHeader.NumEntries]<name="Class Unique Animations",bgcolor=cLtBlue, read=GetClassNamesUni>;
	}classunianim<name="Class Unique Animation Block">;
	
    ClassBaseAnim BaseAnimation<name="Base Animation Block">; byte padding[2]<hidden=true>; // 2
    
    ClassBaseAnim BaseAnimation2<name="Base Animation Block 2?">; //3
    
    ReactionAnimations block4<name="Reaction Animation Block?">; //4
    
    ReactionAnimations block5<name="Reaction Animation Block 2?">; //5
    
    struct MonsterAnimation{ //6
        DataSection sectionHeader<name="Section Header">;
        for (m = 0; m < sectionHeader.NumEntries; m++)
            struct MonsterEntry{
                local MonsterName monster = m;
                Animation attack<name="Attack Animation">;
            }monsterAttack<name="Monster Attack Animation", read=EnumToString(monster), bgcolor=cDkYellow>;
    }monsterBlock<name="Monster Attack Block">;
    
    struct CharacterIdleAnimations { //7
        DataSection sectionHeader<name="Section Header">;
        for (m = 0; m < sectionHeader.NumEntries; m++)
            struct Entry8{
                ModelID character<name="Character">;
                Animation attack<name="Animation">;
            }entry<name="Idle Animation", read=EnumToString(character), bgcolor=cDkYellow>;
    }block8<name="Character Specific Idle Set">;
    
    IdleAnimations block8<name="Default Idle Animation Set">; //8
    
	IdleAnimations block9<name="Byleth Idle?">; //9
	
    struct ClassActSet{ //10
        DataSection sectionHeader<name="Section Header">;
        for( i = 0; i < sectionHeader.NumEntries; i++ )
            struct AnimationSet{
                local ClassID Class<hidden=true>;
                Class = i;
                ClassType Mounted<name="Animation Set Mounted", bgcolor=cDkBlue>;
                ClassType Dismount<name="Animation Set Dismounted", bgcolor=cDkGreen>;
            }actSet<name="Class Animation Set", bgcolor=cLtRed, read=EnumToString(Class)>;
    } block10<name="Class Animation Sets Block">;
    
	GenericSection block11<name="Never Used 11?">; //11
	
    struct Block12 { //12
        DataSection sectionHeader<name="Section Header">;
        for( i = 0; i < sectionHeader.NumEntries; i++ )
            struct Data12{
                local Animation act<hidden=true> = i;
                AnimationType ActType<bgcolor=cRed>;
                ubyte unk;
                ubyte unk;
            }data<read=EnumToString(act), bgcolor=cLtBlue>;
    } block12<comment="Removing this section, removes models and movement">;
	
    struct Block13 { //13
        DataSection sectionHeader<name="Section Header">;
        for( i = 0; i < sectionHeader.NumEntries; i++ )
            struct Data13{
                local MountAnimation act<hidden=true>;
                act = i;
                AnimationType ActType<bgcolor=cRed>;
                ubyte unk;
                ubyte unk;
            }data<read=EnumToString(act), bgcolor=cLtBlue>;
    }block13<name="Mount Related">;
	
    struct sHeadAnim{ //14
        DataSection SectionHeader;
        struct sHeadAnimEntries{
            for(i=0;i<SectionHeader.NumEntries;i++)
                struct sHeadAnimData{
                    byte unkByte0x0[36];
                    short unkShortArray0x24[16];
                    short unkShortArray0x44[16];
                    short unkShortArray0x64[16];
                    short unkShortArray0x84[16];
                    short unkShortArray0xa4[16];
                    byte unkByte0xc4;
                    byte unkByte0xc5;
                    byte unkByte0xc6;
                    byte unkByte0xc7;
                }HeadAnimData;
        } HeadAnimEntries<name="Head Animation Entries">;
        
    } HeadAnim<name="Head Animation Related">;
    
	struct WEAPANIM { //15
		DataSection sectionHeader<name="Section Header">;
		struct WeapAnimData{
			for( i = 0; i < sectionHeader.NumEntries; i++ )
				struct WeapAnimData01 {
					local Item NameOfWeapon<hidden=true>;
				    NameOfWeapon = i;  
					BulletEffectEnum BowEffect;
					WeapAnimType animationSet;
					BulletEffectEnum Effect;
					BulletEffectEnum BowEffectRelic;
					BulletEffectEnum EffectRelic;
				}weapanimdata01<bgcolor=cLtBlue, read=GetWeaponAnimName>;
		}weapanimdata;
	}WeapAnim;
    
    GenericSection block16; byte padding16[2]<hidden=true>; //16
    
    GenericSection block17; //17
    
    GenericSection block18; //18
    
    struct WEAPEFFECTS1 { //19
        DataSection sectionHeader<name="Section Header">;
        struct WEAPEFFECTDATA1{
			local int WeapStringStart<hidden=true> =((Section.SectionPointers[19].Ptr+64) + (sectionHeader.NumEntries*sectionHeader.size));
            uint WeapEffectPointer;
			local string WeaponEffect<name="Weapon Effect"> = ReadString(WeapStringStart+WeapEffectPointer);
            float Scale<name="Scale">;
            float RotationZ<name="Rotation Z">;
            float RotationY<name="Rotation Y">;
            float PositionZ<name="Position Z">;
            float RotationX<name="Rotation X">;
            float PositionX<name="Position X">;
            float PositionY<name="Position Y">;
            short index;
            ubyte Unk;
			ubyte Unk;
            ubyte Unk;
			EffectFlag Flag<name="Effect Flags">;
			ubyte ModelIndex;
			ubyte Padding;
        }WeapEffectData[sectionHeader.NumEntries]<bgcolor=cYellow, name="Effect Data", optimize=false>;
		struct WEAPEFFECTSTRING1{
			for( i = 0; i < sectionHeader.NumEntries; i++ )
			    struct WEAPEFFECTNAME1{
                    string EffectName;
			    }WeapEffectName<read=GetWeapEffectName1, name="Effect Name">;
		}WeapEffectString<name="Effect Strings">;
    }MonsterWeapEffects<name="Monster VFX Strings">;

    struct WEAPEFFECTS { //20
        DataSection sectionHeader<name="Section Header">;
        struct WEAPEFFECTDATA{
			local int WeapStringStart<hidden=true> =((Section.SectionPointers[20].Ptr+64) + (sectionHeader.NumEntries*sectionHeader.size));
            uint WeapEffectPointer;
			local string WeaponEffect<name="Weapon Effect"> = ReadString(WeapStringStart+WeapEffectPointer);
            float Scale<name="Scale">;
            float RotationZ<name="Rotation Z">;
            float RotationY<name="Rotation Y">;
            float PositionZ<name="Position Z">;
            float RotationX<name="Rotation X">;
            float PositionX<name="Position X">;
            float PositionY<name="Position Y">;
            Item Weapon<name="Weapon">;
            ubyte Unk;
			ubyte Unk;
            ubyte Unk;
			EffectFlag Flag<name="Effect Flags">;
			ubyte ModelIndex;
			ubyte Padding;
        }WeapEffectData[sectionHeader.NumEntries]<bgcolor=cYellow, read=GetWeapNames, name="Effect Data", optimize=false>;
		struct WEAPEFFECTSTRING{
			for( i = 0; i < sectionHeader.NumEntries; i++ )
			    struct WEAPEFFECTNAME{
                    string EffectName;
			    }WeapEffectName<read=GetWeapEffectName, name="Effect Name">;
		}WeapEffectString<name="Effect Strings">;
    }WeaponEffects<name="Weapon VFX Data">; byte padding20[2]<hidden=true>;
    
    struct EQUIPMENTEFFECTS { //21
        DataSection sectionHeader<name="Section Header">;
        struct EQUIPMENTEFFECTDATA{
			local int EquipmentStringStart<hidden=false> =((Section.SectionPointers[21].Ptr+64) + (sectionHeader.NumEntries*sectionHeader.size));
            uint EquipEffectPointer;
			local string EquipmentEffect<name="Equipment Effect"> = ReadString(EquipmentStringStart+EquipEffectPointer);
            float Scale<name="Scale">;
            float RotationZ<name="Rotation Z">;
            float RotationY<name="Rotation Y">;
            float PositionZ<name="Position Z">;
            float RotationX<name="Rotation X">;
            float PositionX<name="Position X">;
            float PositionY<name="Position Y">;
            EquipIDShort EquipmentID<name="Equipment">;
            ubyte Unk;
			ubyte Unk;
            ubyte Unk;
			EffectFlag Flag<name="Effect Flags">;
			ubyte ModelIndex;
			ubyte Padding;
        }EquipmentEffectData[sectionHeader.NumEntries]<bgcolor=cYellow, read=GetEquipNames, name="Effect Data", optimize=false>;
		struct EQUIPMENTEFFECTSTRING{
			for( i = 0; i < sectionHeader.NumEntries; i++ )
			    struct EQUIPMENTEFFECTNAME{
				    string EffectName;
			    }EquipmentEffectName<read=GetEquipEffectName, name="Effect Name">;
		}EquipmentEffectString<name="Effect Strings">;
    }EquipmentEffects<name="Equipment Effect Table">; byte padding21[2]<hidden=true>;
	
    struct WEAPAURAEFFECTS { //22
        DataSection sectionHeader<name="Section Header">;
        struct WEAPAURAEFFECTDATA{
			local int WeapAuraStringStart<hidden=true> =((Section.SectionPointers[22].Ptr+64) + (sectionHeader.NumEntries*sectionHeader.size));
            uint AuraEffectPointer;
			local string WeapAuraEffect<name="WeapAura Effect"> = ReadString(WeapAuraStringStart+AuraEffectPointer);
            float Scale<name="Scale">;
            float RotationZ<name="Rotation Z">;
            float RotationY<name="Rotation Y">;
            float PositionZ<name="Position Z">;
            float RotationX<name="Rotation X">;
            float PositionX<name="Position X">;
            float PositionY<name="Position Y">;
            Item Weapon<name="Weapon">;
            ubyte Unk;
			ubyte Unk;
            ubyte Unk;
			EffectFlag Flag<name="Effect Flags">;
			ubyte ModelIndex;
			ubyte Padding;
        }WeapAuraEffectData[sectionHeader.NumEntries]<bgcolor=cYellow, read=GetAuraNames, name="Effect Data", optimize=false>;
		struct WEAPAURAEFFECTSTRING{
			for( i = 0; i < sectionHeader.NumEntries; i++ )
			    struct WEAPAURAEFFECTNAME{
				    string EffectName<bgcolor=cLtGreen>;
			    }WeapAuraEffectName<read=GetAuraEffectName, name="Effect Name">;
		}WeapAuraEffectString<name="Effect Strings">;
    }WeapAuraEffects<name="Weapon Aura Effect Table">; byte padding22[3]<hidden=true>;
    
	GenericSection block23; //23
    
    struct Block24 { //24
        DataSection sectionHeader<name="Section Header">;
        struct Block24_Data {
            int entry[30];
        }data24[sectionHeader.NumEntries];
        struct sEffectNames{
            for (i = 0; i < 30*sectionHeader.NumEntries; ++i){
                struct Block24String{
                    string EffectName<name="Effect Name",bgcolor=cLtGreen>;
                } block27_entry<name="Effect Name",read=EffectName>;
            }
        }EffectNames;
    }block24<name="Terrain VFX Strings">;
    
	struct BULLETTABLE { //25
		DataSection sectionHeader<name="Section Header">;
        local int ptrStart = Section.SectionPointers[25].Ptr + 64;
		struct BULLETDATA {
            uint ptr[9];
            uint unk;
            local string effect1 = ReadString(ptrStart+40*16+ptr[0]);
            local string effect2 = ReadString(ptrStart+40*16+ptr[1]);
            local string effect3 = ReadString(ptrStart+40*16+ptr[2]);
            local string effect4 = ReadString(ptrStart+40*16+ptr[3]);
            local string effect5 = ReadString(ptrStart+40*16+ptr[4]);
            local string effect6 = ReadString(ptrStart+40*16+ptr[5]);
            local string effect7 = ReadString(ptrStart+40*16+ptr[6]);
            local string effect8 = ReadString(ptrStart+40*16+ptr[7]);
            local string effect9 = ReadString(ptrStart+40*16+ptr[8]);
		}BulletData[sectionHeader.NumEntries]<bgcolor=cYellow, optimize=false>;
		struct WEAPBULLETSTRINGS {
			for( i = 0; i < 9*sectionHeader.NumEntries; i++ )
                struct BulletEffectName {
				    string EffectName<bgcolor=cLtGreen>;
                }WeapBulletName<read=EffectName, name="Effect Name">;
        }WeapBulletStrings05<name="Bullet VFX Strings">;
        byte padding<hidden=false>;
	}BulletTable;
    
    struct Block26 { //26
        DataSection sectionHeader<name="Section Header">;
        uint StringOffset[sectionHeader.NumEntries]<name="String Offset">;
        struct sOtherVFX{
            for (i = 0; i < sectionHeader.NumEntries; ++i)
                struct Block27String{
                    string EffectName<bgcolor=cLtGreen>;
                } block26_entry<name="Effect Name", read=EffectName>;
        }OtherVFX;
        byte padding<hidden=false>;
    }block26<name="Hit VFX">;
    
    struct sMonasteryMovementAnimations{ //27
        DataSection sectionHeader;
        struct sMonasteryMovementAnimation{
            byte unkByte0x0[9];
        };
        for(i=0;i<sectionHeader.NumEntries;i++)
            sMonasteryMovementAnimation MonasteryMovementAnimation;
        byte padding[3];
    }MonasteryMovementAnimations<name="Movement-Related Monastery?">;
    
    GenericSection block28<name="Battle Animation-Related", comment="Seems to control Death and hit reaction animations">; //28
}File<name="Act_Data File", open=true>;

string GetWeapNames(WEAPEFFECTDATA &q){            return EnumToString(q.Weapon); }
string GetWeapEffectName(WEAPEFFECTNAME &q){       return StringToWString(q.EffectName, CHARSET_UTF8); }
string GetWeapEffectName1(WEAPEFFECTNAME1 &q){     return StringToWString(q.EffectName, CHARSET_UTF8); }
string GetEquipNames(EQUIPMENTEFFECTDATA &q){      return EnumToString(q.EquipmentID); }
string GetEquipEffectName(EQUIPMENTEFFECTNAME &q){ return StringToWString(q.EffectName, CHARSET_UTF8); }
string GetAuraNames(WEAPAURAEFFECTDATA &q){        return EnumToString(q.Weapon); }
string GetAuraEffectName(WEAPAURAEFFECTNAME &q){   return StringToWString(q.EffectName, CHARSET_UTF8); }
string GetBulletEffectName(BulletEffectName &q){   return StringToWString(q.EffectName, CHARSET_UTF8); };
string GetClassNamesUni(ClassUniAnimData &i){      return EnumToString(i.Class); }
string GetClassNames(ClassActSet &i){              return EnumToString(i.Class); }
string GetWeaponAnimName(WeapAnimData01 &q){       return EnumToString(q.NameOfWeapon); }
string GetSection1Name(CharacterActBlock& q){
    string str;
    if (q.Enabled == 0)
        return EnumToString(q.character) + " Unequipped";
    if (q.EnableClass){
        if (q.character2  != -1)
            str =  EnumToString(q.character2) + " " + EnumToString(q.character);
        else return EnumToString(q.character) + " " + EnumToString(q.class) + " " + EnumToString(q.Weapon);
    }
    if (q.character2  != -1)
        str =  EnumToString(q.character2) + " " + EnumToString(q.character);
    else str = EnumToString(q.character);
    return str + ": " + EnumToString(q.Weapon);
};
string BaseAnimationName(ClassBaseAnimData& q){
    string gender = EnumToString(q.gender);
    if (gender == "Both") gender = "";
    else gender += " ";
    string str = gender + EnumToString(q.classType);
    if (q.Enabled == 0) str += " Unequipped";
    else str +=  " " + EnumToString(q.Weapon) + ": " + EnumToString(q.animation);
    return str;
};